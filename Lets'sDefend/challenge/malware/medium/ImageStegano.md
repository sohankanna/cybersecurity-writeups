# ImageStegano

## Challenge Description 

<img width="1190" height="525" alt="image" src="https://github.com/user-attachments/assets/37a33857-c234-4627-8bc4-22d01a366349" />


## Solution and Analysis 

### **Step 1: Metadata Analysis**

The first step is to analyze the image's metadata to gather initial clues. The `exiftool` utility is perfect for this task. Use the Ubuntu CLI located in the VM for this 

**Command:**
```bash
exiftool Sd6wF1A1v.png
```

<img width="958" height="502" alt="Screenshot 2025-09-04 204551" src="https://github.com/user-attachments/assets/5eb80d24-1579-4563-8842-6cde74ad20e1" />


This command extracts and displays all embedded metadata from the PNG file.

#### **Question 1: Who is the “Device Manufacturer” according to the metadata?**

By inspecting the output from `exiftool`, we can locate the `Make` or `Device Manufacturer` field.

> **Answer:** The answer is listed next to the **`Make`** tag in the output.

#### **Question 2: What is the CMM Type?**

Similarly, the CMM (Color Management Module) type is also available in the metadata.

> **Answer:** The value is found next to the **`Profile CMM Type`** field in the output.

---

### **Step 2: Identifying the Steganography Tool**

The challenge involves a PowerShell payload hidden within an image. Research into common tools for this purpose points to a popular script designed for embedding PowerShell into the pixel data of PNG files.

#### **Question 3: What is the tool that created the payload inside the image?**

> **Answer:** The tool is **`Invoke-PSImage`**. It's a PowerShell-based script that uses the least significant bits of pixel color values to embed a script, making it a common choice for steganographic attacks.

---

### **Step 3: Extracting the Hidden Payload**

To analyze the payload, we first need to extract it from the image. A Python-based decoder designed to reverse the `Invoke-PSImage` process is required, I searched upon a couple of scripts but the one that worked the most was found at `https://github.com/mertsarica/hack4career/blob/master/codes/psimage_decoder.py`

**Setup:**
First, ensure the necessary Python library is installed:
```bash
pip install Pillow
```

**Execution:**
With the decoder script and the PNG file in the same directory, run the following command. This will execute the script and redirect its output (the decoded payload) into a new file.

```bash
python psimage_decoder.py Sd6wF1A1v.png > output.txt
```

This creates a file named `output.txt` containing the hidden PowerShell code.

---

### **Step 4: Analyzing the Decoded Payload**

Now we can inspect the contents of `output.txt` to understand its purpose.

#### **Question 4: After decoding the payload, can you find out the function's name?**

Upon opening the extracted script, the primary malicious function is immediately identifiable.

> **Answer:** The function is **`Invoke-Mimikatz`**.

### Analysis of Invoke-Mimikatz

The presence of `Invoke-Mimikatz` signifies a serious post-exploitation attack focused on credential theft. It is a fileless, in-memory version of the powerful Mimikatz tool.

*   **Primary Goal:** To dump credentials (plaintext passwords, NTLM hashes, and Kerberos tickets) from the memory of the **Local Security Authority Subsystem Service (LSASS)** process on a Windows machine.
*   **Stealth:** It runs entirely in memory, avoiding detection by traditional file-based antivirus solutions.
*   **Impact:** Successful execution allows an attacker to perform lateral movement across a network using techniques like **Pass-the-Hash** and **Pass-the-Ticket**, potentially leading to a full domain compromise.

#### **Question 5: There are two hidden executables in the decoded payload. What is the SHA256 hash of the 32-bit version of the executable?**

The `Invoke-Mimikatz` script contains Base64-encoded strings that represent 32-bit (x86) and 64-bit (x64) versions of the Mimikatz executable. The script decodes these strings and loads them into memory as byte arrays.

To find the answer, open `extracted_payload.ps1` in a text editor and search for keywords associated with the 32-bit version, such as `x86`, `32-bit`, or its corresponding SHA256 hash.

> **Answer:** By searching the file, you can locate a comment or variable assignment containing the SHA256 hash for the 32-bit executable.

---

## Conclusion

This challenge effectively demonstrated a modern attack chain:
1.  **Delivery:** Using a seemingly harmless PNG image.
2.  **Evasion:** Hiding a malicious PowerShell script via steganography (`Invoke-PSImage`).
3.  **Execution:** Employing a fileless, in-memory technique to run a powerful credential harvester (`Invoke-Mimikatz`).

Analyzing each stage, from metadata to the final payload, is crucial for understanding and defending against such threats.


